NAME=hub-quay-agent
AUTHOR ?= appvia
AUTHOR_EMAIL=gambol99@gmail.com
REGISTRY=quay.io
GOVERSION ?= 1.11.1
APIVERSION=v1beta
ROOT_DIR=${PWD}
HARDWARE=$(shell uname -m)
GIT_SHA=$(shell git --no-pager describe --always --dirty)
BUILD_TIME=$(shell date '+%s')
VERSION ?= $(shell awk '/release.*=/ { print $$3 }' cmd/hub-quay-agent/main.go | sed 's/"//g')
DEPS=$(shell go list -f '{{range .TestImports}}{{.}} {{end}}' ./...)
PACKAGES=$(shell go list ./...)
LFLAGS ?= -X main.gitsha=${GIT_SHA} -X main.compiled=${BUILD_TIME}
VETARGS ?= -asmdecl -atomic -bool -buildtags -copylocks -methods -nilfunc -printf -rangeloops -structtags -unsafeptr

.PHONY: test authors changelog build docker static release lint cover vet glide-install

default: build

golang:
	@echo "--> Go Version"
	@go version

build: golang
	@echo "--> Compiling the project"
	@mkdir -p bin
	go build -ldflags "${LFLAGS}" -o bin/${NAME} cmd/${NAME}/*.go

static: golang deps
	@echo "--> Compiling the static binary"
	@mkdir -p bin
	CGO_ENABLED=0 GOOS=linux go build -a -tags netgo -ldflags "-w ${LFLAGS}" -o bin/${NAME} cmd/${NAME}/*.go

docker-build:
	@echo "--> Compiling the project"
	docker run --rm \
		-v ${ROOT_DIR}:/go/src/github.com/${AUTHOR}/${NAME} \
		-w /go/src/github.com/${AUTHOR}/${NAME} \
		-e GOOS=linux golang:${GOVERSION} \
		make static

docker-release:
	@echo "--> Building a release image"
	@$(MAKE) static
	@$(MAKE) docker
	@docker push ${REGISTRY}/${AUTHOR}/${NAME}:${VERSION}

docker: static
	@echo "--> Building the docker image"
	docker build -t ${REGISTRY}/${AUTHOR}/${NAME}:${VERSION} .

release: static
	mkdir -p release
	gzip -c bin/${NAME} > release/${NAME}_${VERSION}_linux_${HARDWARE}.gz
	rm -f release/${NAME}

clean:
	rm -rf ./bin 2>/dev/null
	rm -rf ./release 2>/dev/null

authors:
	@echo "--> Updating the AUTHORS"
	git log --format='%aN <%aE>' | sort -u > AUTHORS

dep-install:
	@echo "--> Installing dependencies"
	@dep ensure

deps:
	@echo "--> Installing build dependencies"
	@go get -u github.com/golang/dep/cmd/dep
	@$(MAKE) dep-install

vet:
	@echo "--> Running go vet $(VETARGS) $(PACKAGES)"
	@go tool vet 2>/dev/null ; if [ $$? -eq 3 ]; then \
		go get golang.org/x/tools/cmd/vet; \
	fi
	@go vet $(VETARGS) $(PACKAGES)

gofmt:
	@echo "--> Running gofmt check"
	@gofmt -s -l *.go \
	    | grep -q \.go ; if [ $$? -eq 0 ]; then \
            echo "You need to runn the make format, we have file unformatted"; \
            gofmt -s -l *.go; \
            exit 1; \
	    fi

verify:
	@echo "--> Verifying the code"
	gometalinter --disable=errcheck --disable=gocyclo --disable=gas --disable=aligncheck --errors

format:
	@echo "--> Running go fmt"
	@gofmt -s -w *.go

bench:
	@echo "--> Running go bench"
	@go test -bench=. -benchmem

coverage:
	@echo "--> Running go coverage"
	@go test -coverprofile cover.out
	@go tool cover -html=cover.out -o cover.html

quay-swagger:
	@echo "--> Downloading the Quay API spec"
	@mkdir -p pkg/client
	@curl -sL https://quay.io/api/v1/discovery | jq > swagger.client.json

quay-client: golang go-swagger
	@echo "--> Validated the Quay API scheme"
	swagger validate swagger.client.yml
	@echo "--> Generating the Quay API Client"
	@mkdir -p pkg/quay/client
	swagger generate client \
		--api-package=quay \
		--copyright-file=COPYRIGHT \
		--spec=swagger.client.yml \
		--target=pkg/quay \
		--with-flatten=full

clean-query-client:
	@echo "--> Cleaning up the Quay client"
	rm -rf pkg/client 2>/dev/null

api-validate: golang go-swagger
	@echo "--> Validated the API scheme"
	swagger validate swagger.api.yml

api:
	@echo "--> Generate the HTTP API"
	@mkdir -p pkg/transport/restapi
	swagger generate server \
		--copyright-file=COPYRIGHT \
		--exclude-main \
		--regenerate-configureapi \
		--server-package=restapi \
		--spec=swagger.api.yml \
		--target=pkg/transport \
		--with-flatten=full

clean-api:
	@echo "--> Cleaning up the autogenerated API"
	@rm -rf pkg/models 2>/dev/null
	@rm -rf pkg/transport/restapi 2>/dev/null

clean-all:
	@echo "--> Cleaning up the autogenerated API"
	@rm -rf pkg/client 2>/dev/null
	@rm -rf pkg/models 2>/dev/null
	@rm -rf pkg/transport/models 2>/dev/null
	@rm -rf pkg/transport/restapi 2>/dev/null

go-swagger:
	@echo "--> Installing go-swagger tools"
	@swagger version >/dev/null 2>&1; if [ $$? -ne 0 ]; then \
		echo "--> Installing the go-swagger tools"; \
		go install github.com/go-swagger/go-swagger/cmd/swagger; \
	fi

lint:
	@echo "--> Running golint"
	@which golint 2>/dev/null ; if [ $$? -eq 1 ]; then \
    go get -u github.com/golang/lint/golint; \
  fi
	@golint $(PACKAGES)

cover:
	@echo "--> Running go cover"
	@go test --cover $(PACKAGES)

spelling:
	@echo "--> Checking the spelling"
	@which misspell 2>/dev/null ; if [ $$? -eq 1 ]; then \
		go get -u github.com/client9/misspell/cmd/misspell; \
	fi
	@misspell -error *.go
	@misspell -error *.md

test:
	@echo "--> Running the tests"
	@if [ ! -d "vendor" ]; then \
		make dep-install; \
  fi
	@go test -v $(PACKAGES)
	@$(MAKE) golang
	@$(MAKE) gofmt
	@$(MAKE) lint
	@$(MAKE) spelling
	@$(MAKE) vet
	@$(MAKE) cover

all: test
	echo "--> Performing all tests"
	@${MAKE} verify
	@$(MAKE) bench
	@$(MAKE) coverage

changelog: release
	git log $(shell git tag | tail -n1)..HEAD --no-merges --format=%B > changelog
